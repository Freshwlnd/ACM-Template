遍历方式：
//第一层从[0,pw(n)-1]的遍历方式，正好从前到后扫到所有n个位置变化状态
//第二层可以检验某一位是否存在，从而做出操作
for(int i=0;i<pw(n);i++){
    for(int j=0;j<n;j++){
        if(pw(j)&i){
            ......
        }
    }
}


//矩阵类型的遍历，通过预处理减少不必要的状态来降低复杂度
int main(){
    int x;
    scanf("%d%d",&n,&m);
    int top=pw(m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&x);
            g[i]=(g[i]<<1)+x; //预处理状态，将其直接保存
        }
    }
    a[0]=0;
    for(int i=0;i<top;i++){
        if((((i<<1)&i)==0)&&(((i>>1)&i)==0)){
            a[++a[0]]=i; //通过移位操作，预处理出相邻不为1的状态
        }
    }
    dp[0][0]=1;
    for(int i=1;i<=n;i++){
    	//遍历矩阵上下关系来处理
        for(int j=1;j<=a[0];j++){
        	...
            for(int k=1;k<=a[0];k++){
                ...
            }
        }
    }
    ll ret=0; //答案统计
    for(int i=0;i<top;i++) ret=(ret+dp[n][i])%mod;
    printf("%lld\n",ret);
}

//初始化状态，然后用已有状态去推导接下来的状态，写起来有时候会方便很多
for(int i=0;i<n;i++) if(p[i]==-1||p[i]==0) dp[pw(i)][i]=0;
for(int i=0;i<top;i++){
    for(int j=0;j<n;j++){
        if(dp[i][j]==-inf) continue;
        for(int k=0;k<n;k++){
            if(k==j) continue;
            if(p[k]==-1||p[k]==cnt[i]){
                if(pw(k)&i) continue;
                dp[i|pw(k)][k]=max(dp[i|pw(k)][k],dp[i][j]+a[j]*a[k]);
            }
        }
    }
}


//可以快速求出所有关于S的二进制子集
int S=i;
for (int s=(S-1)&S;s;s=(s-1)&S) {
     int t=S^s;
}

//二进制转化
去掉最后一位          |(101101->10110) |               x >> 1
在最后加一个0        |(101101->1011010) |            x < < 1
在最后加一个1        |(101101->1011011) |            x < < 1+1
把最后一位变成1     |(101100->101101) |              x | 1
把最后一位变成0     |(101101->101100) |              x | 1-1
最后一位取反          |(101101->101100) |             x ^ 1
把右数第k位变成1    | (101001->101101,k=3) |      x | (1 < < (k-1))
把右数第k位变成0    | (101101->101001,k=3) |      x & ~ (1 < < (k-1))
右数第k位取反        | (101001->101101,k=3) |       x ^ (1 < < (k-1))
取末三位               | (1101101->101) |                x & 7
取末k位                | (1101101->1101,k=5) |        x & ((1 < < k)-1)

取右数第k位           | (1101101->1,k=4) |             x >> (k-1) & 1
把末k位变成1         | (101001->101111,k=4) |       x | (1 < < k-1)
末k位取反              | (101001->100110,k=4) |      x ^ (1 < < k-1)
把右边连续的1变成0 | (100101111->100100000) |   x & (x+1)
把右起第一个0变成1 | (100101111->100111111) |   x | (x+1)
把右边连续的0变成1 | (11011000->11011111) |      x | (x-1)
取右边连续的1        | (100101111->1111) |           (x ^ (x+1)) >> 1
去掉右起第一个1的左边 | (100101000->1000) |       x & (x ^ (x-1))
判断奇数                   (x&1)==1
判断偶数                    (x&1)==0 
取右边第一个1所在位置  x&-x

//轮廓线dp，思想是将状态看成了一条轮廓线，通过当前遍历到的位置旁边的轮廓线，进行状态转移

例题：现在有一个n*m的矩阵，想用1*2或2*1的小矩形进行填充，求全部填满的方案数

xxxxxxxxxxxx
xxxxxyyyyyyy
yyyyyzzzzzzz

从图中可以看出，x的位置已经填好，而y的位置状态还不确定，z是要准备处理的位置。那么就可以有以下四种状态:
   10 11 11 10
   0  1  0  1
1）必须填竖着 2）可填可不填 3）可填可不填 4）必须填竖着

int main(){
    while(scanf("%d%d",&n,&m)==2){
        if(n==0&&m==0) break;
        int top=pw(m);
        memset(dp[0],0, sizeof(ll)*(top));
        dp[0][top-1]=1;
        int u=1,v=0;
        for(int i=1;i<=n;i++){
            for(int j=0;j<m;j++,swap(u,v)){
                memset(dp[u],0, sizeof(ll)*(top));
                for(int k=0;k<top;k++){
                    if(j&&!check(pw(j-1),k)&&check(pw(j),k)) dp[u][k|pw(j-1)]+=dp[v][k];
                    if(!check(pw(j),k)) dp[u][k|pw(j)]+=dp[v][k];
                    else dp[u][k^pw(j)]+=dp[v][k];
                }
            }
        }
        printf("%lld\n",dp[v][top-1]);
    }
    return 0;
}