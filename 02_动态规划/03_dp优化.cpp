1、斜率优化
int tail=0,head=0;
q[tail++]=0;
for(int i=1;i<=n;i++){
    //判断答案是否最优
    while(tail>1+head&&isOK(i,q[head+1],q[head])) head++;
    dp[i]=getsum(i,q[head]);
    //判断新加入的点是否最优
    while(tail>1+head&&isOK2(i,q[tail-1],q[tail-2])) tail--;
    q[tail++]=i;
}
printf("%lld\n",dp[n]);

2、四边形不等式
在dp问题中,我们常遇见这样的一类问题，他们的dp转移方程式这样的：dp[i][j]=min{dp[i][k]+dp[k+1][j]+cost[i][j]}

对于(a<b<=c<d)，如果有f[a][c]+f[b][d]<=f[b][c]+f[a][d]，则说明f满足四边形不等式
1、当决策代价函数w[i][j]满足w[i][j]+w[i'][j']<=w[i'][j]+w[i][j'] (i<=i'<=j<=j')时，称满足四边形不等式
2、当函数w[i][j]满足w[i'][j]<=w[i][j'] (i<=i'<=j<=j')时,称w关于区间包含关系单调.
结论：若决策代价函数满足四边形不等式，包含关系单调，且dp[i][j]方程也满足四边形不等式，设s[i][j]表示
dp[i][j]取得最优值时对应的下标，即(i<=k<=j)。就满足s[i][j-1]<=s[i][j]<=s[i+1][j]。

一般做法：
对于dp转移合法的证明，其实很多时候直接打表就行了，比如先跑一个O（n^3）的代码，跑的时候判断是否满足四边形不
等式，决策是否单增等等，如果不满足就输出false之类的，或者打一个决策表出来观察，这样其实会省下一部分时间。

//判断是否满足平行四边形不等式优化w[i][j]+w[i+1][j+1]<=w[i+1][j]+w[i][j+1]
bool isOK(){
    for(int i=1;i<n;i++){
        for(int j=i+2;j<n;j++){
            if(w[i][j]+w[i+1][j+1]<=w[i+1][j]+w[i][j+1]) continue;
            else return false;
        }
    }
    return true;
}


    四边形不等式优化代码十分简单,且效果也很好,但是最令人头疼的就是如何证明w满足四边形不等式。有可能这个对大家还比较容易，但是要
知道，满足这些性质的转移方程不止这一种！对于f[i][j] = min{ f[i-1][k] + w(k+1,j) | i-1 <= k < j }这个方程来说，若w满足四
边形不等式，f同样满足四边形不等式，也可以使用决策单调性优化，但是证明就比较困难了。YJQ教给我一种很好的绕过证明使用四边形不等式的
方法，但是使用起来不是那么简单，有一些注意事项。下面的内容可就是别人博客里没有的东西了！
　　大致方法很简单，如果我们觉得一个方程能用四边形不等式优化，就把他的所有决策点，也就是p矩阵打印出来，观察一下在每行每列上是否单
调，如果单调，就说明这个方程可以用四边形不等式优化。不过需要小心一些地方。首先，注意决策点应该在哪些范围之内单调，比如对于区间dp
的方程来说，决策点的单调范围就应该是行号小于等于列号的那一部分。这点在实际问题中应该很容易体现出来，比如对于区间dp，行号大于列号
的那些状态肯定是无用的，决策单调性也肯定不关它们什么事。
    其次，应该注意递推时枚举的顺序和状态之间的依赖关系。比如对于上面那个方程来说，决策矩阵p在每行每列单调递增，所以应该把k的枚举
范围该成p[i-1][j]至p[i][j+1]，注意这里和区间dp就不一样了，所以应该根据状态之间的依赖关系灵活调整枚举范围。而且，如果我们遵循这
样的依赖关系，就应该有p[i][j]依赖于p[i][j+1]，所以k应该从大到小倒着枚举.