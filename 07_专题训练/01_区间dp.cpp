区间dp:顾名思义,区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的最优解进而得出整个大区间上最优解的dp算法。
其基础代码为：
for(int len=2;len<=n;len++){
  for(int i=1;i+len-1<=n;i++){
    int j = i+len-1;
    for(int k=i;k<j;k++){
      dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+cost[]);
    }
  }
}
其实是一个相对非常暴力的方法去求解最优问题，所以数据量在[100,800]之间的可以考虑O(n^3)求解,而破千通过题目内在关系降到O(n^2)进行求解。而
dp[i][j]的初始化可以在循环内进行，可以通过内外关系一同确定一个区间的最优值。

下面对一些精彩的题目进行分析：

1）Cake(zoj 3537)
题意：
    有一块多边形蛋糕，切一刀的代价为|x1+x2|*|y1+y2|%p,如果蛋糕为凸多边形则求出全部切成三角形的代价，否则输出无法切。

思路:
    首先使用凸包判断是否为多边形，然后通过凸包得到点的序列，将n->2n,减去环的麻烦。设dp[i][j]表示点[i,j]所组成的多边形被切成三角形所需的
最少代价。可以设k为[i+1,j-1]，通过区间扫描即可获得最终结果。

2）Coloring Brackets(https://codeforces.com/problemset/problem/149/D)
题意：
    有一串包含()的字符串，保证合法，最初颜色为黑色，现需要满足3个条件：1.每种括弧都要有一种颜色 2.相匹配的括弧只有一种染了红色或者黑色
3.若括弧被染色，则相邻的括弧颜色不能相同，求最大组合数量，结果mod(1e9+7)。

思路：
    本题思路较为奇特,设dp[N][N][3][3]，dp[i][j][x][y]表示在区间[i,j]中，最左边括弧颜色为x,最右边括弧颜色为y的合法括弧序列可以染色的
最大数量。那么接下来只需要分类讨论即可获得最优解。

代码：
for(int L=3;L<=len;L++){
        for(int i=1;i+L-1<=len;i++){
            int j = i+L-1;
            if(s[i]=='('&&to[i]==j){
                dp[i][j][0][1] = (dp[i][j][0][1]+dp[i+1][j-1][1][0]+dp[i+1][j-1][0][2]
                +dp[i+1][j-1][2][0]+dp[i+1][j-1][0][0]+dp[i+1][j-1][2][2]+dp[i+1][j-1][1][2])%mod;
                dp[i][j][1][0] = (dp[i][j][1][0]+dp[i+1][j-1][0][1]+dp[i+1][j-1][2][0]
                +dp[i+1][j-1][0][2]+dp[i+1][j-1][0][0]+dp[i+1][j-1][2][2]+dp[i+1][j-1][2][1])%mod;
                dp[i][j][2][0] = (dp[i][j][2][0]+dp[i+1][j-1][0][1]+dp[i+1][j-1][1][0]
                +dp[i+1][j-1][0][2]+dp[i+1][j-1][0][0]+dp[i+1][j-1][1][1]+dp[i+1][j-1][1][2])%mod;
                dp[i][j][0][2] = (dp[i][j][0][2]+dp[i+1][j-1][1][0]+dp[i+1][j-1][0][1]
                +dp[i+1][j-1][2][0]+dp[i+1][j-1][0][0]+dp[i+1][j-1][1][1]+dp[i+1][j-1][2][1])%mod;
            }else if(s[i]=='('&&s[j]==')'){
                int k = to[i];
                for(int x=0;x<3;x++){
                    for(int y=0;y<3;y++){
                        for(int q1=0;q1<3;q1++){
                            for(int q2=0;q2<3;q2++){
                                if(q1==q2&&q1!=0)
                                    continue;
                                dp[i][j][x][y]=(dp[i][j][x][y]+dp[i][k][x][q1]*dp[k+1][j][q2][y])%mod;
                            }
                        }
                    }
                }
            }
        }
    }
反思：
    区间dp不可以局限于简单的二维，可以通过实际情况进行设立情况，本题的难点在于意义的定义，将其定义成合法尤为重要。

3）You Are the One(hdu 4283)
题意：
    有一个序列，每个人带着屌丝值di,第k个上场的人会增加评委(k-1)*di，现在有一个小黑屋，可以让人先进去后出来，模拟堆栈，求最少的屌丝值
总和。

思路：
    设dp[i][j]表示在[i,j]区间所增加的最少屌丝值，这时候赋予k表示第i个人是第k个人进入，这时候存在 dp[i][j] = min(dp[i][j],
dp[i+1][i+k-1]+dp[i+k][j]+(k-1)*a[i]+k*(pre[j]-pre[i+k-1]))的状态转移方程。

反思：
    赋予k特殊含义，来求解。

4）Palindrome subsequence(hdu 4632)
题意：
    给一串字符，求解其中有多少个回文串，只要下标不同，回文串之间就是不同。

反思：
    设数组为dp[N][N],其中dp[i][j]表示[i,j]区间拥有回文串的最大数量，显然有dp[i][j] = ((dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]
)%mod+mod)%mod 和 if(s[i-1]==s[j-1])  dp[i][j]=(dp[i][j]+1+dp[i+1][j-1])%mod;

5）Two Rabbits(hdu 4745)
题意：
    现有一串石碓，围城一圈，两个兔子分别逆时针和顺时针跳，每次跳的石头权值相同，问最长的可行石碓序列长为多少。

思路：
    考虑到一个回文串或者两个回文串可以组成一个满足要求的序列。因此可以先将石碓的回文情况求出然后进行求解。

代码：
for(int i=1;i<=n;i++)
    dp[i][i]=1;
for(int len = 2;len<=n;len++){
   for(int i = 1;i+len-1<=2*n;i++){
       int j = i+len-1;
       dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
       if(a[i]==a[j])
          dp[i][j]=max(dp[i][j],dp[i+1][j-1]+2);
    }
}
int res=1;
for(int i=1;i<=n;i++){
    int j = i+n-1;
    for(int k=i;k<j;k++){
        res = max(res,dp[i][k]+dp[k+1][j]);
    }
}
printf("%d\n",res);

6）Sit sit sit（hdu 5151）
题意：
    现在有一个被染色为01的椅子，需要安排座位上座顺序，满足三种情况的不能坐：1.两边都有人坐了 2.两边都有椅子 3.左右被坐颜色不同
现求所有可行方案mod(1e9+7)

思路：
    设第k个人为最后上座，加上一些组合数知识即可写出。

7）D-game
题意：
    现在给了一个序列，并一个D{}集合，序列的公差要满足D集合中元素。1. 在当前剩下的有序数组中选择X(X≥2) 个连续数字；2. 检查1选择
的X个数字是否构成等差数列，且公差 d∈{D}；3. 如果2满足，可以在数组中删除这X个数字；4. 重复 1−3 步，直到无法删除更多数字。求最多能
删除几个数。

代码：
for(int len=2;len<=n;len++){
   for(int i=1;i+len-1<=n;i++){
       int j = i+len-1;
       if(len==2){
          if(mp[a[j]-a[i]])
             dp[i][j]=1;
        }else if(len==3){
             if(mp[a[j-1]-a[i]]&&2*a[j-1]==a[j]+a[i])
                  dp[i][j]=1;
        }else{
             if(mp[a[j]-a[i]]&&dp[i+1][j-1])
                dp[i][j]=1;
             for(int k=i+1;k<j;k++){
                 dp[i][j] |= dp[i][k]&dp[k+1][j];
             }
        }
   }
}
memset(res,0, sizeof(res));
for(int j=1;j<=n;j++){
    res[j]=res[j-1];
    for(int i=1;i<=j;i++){
        if(dp[i][j])
           res[j]=max(res[j],res[i-1]+j-i+1);
    }
}
printf("%d\n",res[n]);