规律总结：
1、期望可以分解成多个子期望的加权和，权为子期望发生的概率，即E(aA+bB...)=aE(A)+bE(B)+...+1
2、期望从后往前找，一般dp[n]=0,dp[0]是答案
3、解决过程，找出各种情况乘上这种情况发生的概率，求和

1、Favorite Dice (spoj)
题意：
    甩一个n面的骰子，问每一面都被甩到的次数期望是多少？

思路：
    设dp[i]表示取了i种数时还需要数的期望,显然dp[n]=0,求解dp[0]为多少.本题很神奇,正着推死活推不出来,需要倒着推.
反推显然满足这个式子,dp[i]=1+i/n*dp[i]+(n-i)/n*dp[i+1],推出来为dp[i]=dp[i-1]+n/(n-i),扫一遍[n-1,0]区间即可.

核心代码：
dp[n] = 0;
for (int i = n - 1; i >= 0; i--)
    dp[i] = dp[i + 1] + 1.0*n /(n - i);
printf("%.2lf\n", dp[0]);

2、LOOPS (hdu3853)
题意：
    一个女生走迷宫，只有向下和向右走和保持在原地，每走一次会消耗掉2的魔力，求从(1,1)成功走到(r,c)所花魔力的期望。

思路：
    设dp[r][c]=0，那么有满足状态转移方程 dp[i][j] = p1*dp[i][j]+p2*dp[i][j+1]+p3*dp[i+1][j]+2
转化成  dp[i][j] = (p2*dp[i][j+1]+p3*dp[i+1][j]+2)/(1-p1) 即可

核心代码：
for (int i = r; i >= 1; i--) {
    for (int j = c; j >= 1; j--) {
	if (i == r && j == c)
		continue;
	if (p[i][j].p1 == 1)
		continue;
	dp[i][j] = (p[i][j].p2*dp[i][j + 1] + 2 + p[i][j].p3*dp[i + 1][j]) / (1 - p[i][j].p1);
    }
 }
   
 反思：
    dp[i][j]表示在(i,j)这个点时，还差多少魔力值才能到达终点的期望。
    最开始的时候dp[i][j]将未来的状态也加入其中，其实那种想法是错误的，因为当前还未确定，未来也不会确定，因此状态转移方程所含
 的应该是当前不确定的dp[i][j]和之前已经推导出的状态来推导出dp[i][j]最终推导dp[1][1]的时候就是答案。
 
3、King Arthur's Birthday Celebration(poj3682)
题意：
    有个国王过生日，投硬币，投到k次正面朝上就结束宴会，正面朝上概率为p，每一天投一次，花钱量1、3、5、7...这样递增。求
结束宴会的期望天数和期望花钱量。

思路：
    设dp[i]表示投中i次后，还需要天数的期望。显然满足 dp[i]=(1-p)*dp[i]+p*dp[i+1]+1 => dp[i]=dp[i+1]+1/p。 
dp2[i]表示投中i次后，还需要花钱的期望，显然满足 dp2[i]=(1-p)*(dp2[i]+2*(dp[i]+1)-1)+p*(dp2[i+1]+2*(dp[i+1]+1)-1).
=> 得到 dp2[i]=dp2[i]+2dp[i+1]+1+(1-p)(2dp[i]+1)/p。然后dp[n]=dp2[n]=0,for循环一下就可以得到答案。
   也可以正推,显然满足 dp[i]=(1-p)*dp[i]+p*dp[i-1]+1 => dp[i]=dp[i-1]+1/p,
dp2[i]=(1-p)*(dp2[i]+2*dp[i]-1)+p*(dp2[i+1]+2*dp[i+1]-1)+2.然后dp[0]=dp2[0]=0,for循环一下就可以得到答案。

反思:
    概率题可以用dp方式求得,两个不同的概率题也可以用dp方程之间建立联系.
    
4、烟花 (https://ac.nowcoder.com/acm/contest/180/B)
题意：
    小a有n个烟花，每个烟花代表着互不相同的颜色，对于第i个烟花，它有pi的概率点燃，现在小a要去点燃它们，
他想知道产生颜色的期望个数及产生恰好产生k种颜色的概率。

思路：
   第一个就是简单期望相加，即E(x)=sigma(pi)
   1、设方程dp[k][N],那么dp[i][j]表示有j个烟花，其中i个燃放的概率。初始化dp[0][0]=1,dp[0][i]=
(1-p[1])(1-p[2])...(1-p[i])。那么就有dp[i][j]=dp[i-1][j-1]*p[j]+dp[i][j-1]*(1-p[j]),那么
dp[k][n]即为所求答案。
   2、设方程dp[N][K],那么dp[i][j]表示有i个烟花，其中有j个被燃放的概率。因为此循环使用的是for(N),
因此只用记录n-1的状态即可。因此可以使用滚动数组，设o=0，初始状态为dp[o][0]=1-p[1],dp[o][1]=p[1]。
状态转移方程为dp[o][j]=dp[o^1][j]*(1-p[i])+dp[o^1][j-1]*p[i],其中j<=min(i,k)即可。

5、流星雨(https://ac.nowcoder.com/acm/contest/368/C)
题意：
    现在一共有n天，第i天如果有流星雨的话，会有wi颗流星雨。第i天有流星雨的概率是pi。如果第一天有流星雨了，
那么第二天有流星雨的可能性是p2+P，否则是p2。相应的，如果第i−1 (i≥2)天有流星雨，第i天有流星雨的可能性是
pi+P，否则是pi。求n天后，流星雨颗数的期望。

思路：
    设dp[i]表示第i天会发生流星雨的概率，那么dp[i]只和dp[i-1]有关，满足：dp[i]=dp[i-1]*(pi+p)+
(1-dp[i-1])*p。然后只需乘上每天的流星雨数量即可得到答案。

反思：
    这道题我只想着如何直接推导推导期望公式，导致推出来的公式非常耗时间，公式如下：
dp[i]=dp[i-1]+(p^(i-1)*p[1]+...+p^0*p[i])*w[i]。状态转移方程是对的，但是时间会超，因为可以考虑期望的定义
即E(x)=p[x]*w[x],我们分段求出期望最后累加就是结果。

6、One Person Game(zoj3329)
题意：
    有三个骰子，分别有k1,k2,k3个面。每次掷骰子，如果三个面分别为a,b,c则分数置0,否则加上三个骰子的分数之和。
当分数大于n时结束。求游戏的期望步数。初始分数为0

思路：
    设dp[i]表示达到i分时到达目标状态的期望，pk为投掷k分的概率，p0为回到0的概率则dp[i]=∑(pk*dp[i+k])+dp[0]*p0+1;
都和dp[0]有关系，而且dp[0]就是我们所求，为常数设dp[i]=A[i]*dp[0]+B[i];代入上述方程右边得到：
dp[i]=∑(pk*A[i+k]*dp[0]+pk*B[i+k])+dp[0]*p0+1=(∑(pk*A[i+k])+p0)dp[0]+∑(pk*B[i+k])+1;明显A[i]=(∑(pk*A[i+k])+p0)
B[i]=∑(pk*B[i+k])+1,先递推求得A[0]和B[0]. 那么dp[0]=B[0]/(1-A[0]);

7、Dice(hdu 4652)
题意：
    现在有一个m面骰子,每个面都有一个特定的数,现在有2个操作,1：询问投出最后连续n个相同数字的期望 2：询问投出最后n个不连续
数字的期望.

思路:
    对于1情况,我们可以设dp[n]=0,有关系式dp[i]=1+dp[i+1]/m+(m-1)*dp[1]/m,通过dp[i+2]-dp[i+1]=m*(dp[i+1]-dp[i]),可以得到
dp[0]-dp[1]=1,dp[1]-dp[2]=m,...,dp[n-1]-dp[n]=m^(n-1),可以得到dp[0]=(m^n-1)/(m-1)
    对于2情况,要注意是连续n个数不相同,因此dp[n]=0,dp[i]=1+(m-i)*dp[i]/m+(dp[1]+dp[2]+...dp[i])/m,因为如果加入相同的数,那么
会随着数字的不同回到的原始点不同,因此有了(dp[1]+dp[2]+...dp[i])/m,方法如上递推即可.
    
8、Maze(hdu 4035)
题意：
    有n个房间,由n-1条隧道连通起来,实际上就形成了一棵树,从结点1出发,开始走,在每个结点i都有3种可能:1.被杀死,回到结点1处（概率为ki）
2.找到出口，走出迷宫 （概率为ei） 3.和该点相连有m条边，随机走一条. 求：走出迷宫所要走的边数的期望值。

思路：
    设dp[i]=Ai*dp[1]+Bi*dp[fa[i]]+Ci,re[i]=1-ki-ei,other=re[i]/m
    关于叶子节点：dp[i]=ki*dp[1]+Ei*0+other*(dp[fa[i]]+1)=ki*dp[1]+other*dp[fa[i]]+other,因此可以得到叶子节点:
Ai=ki,Bi=other,Ci=other
    关于非叶子节点:dp[i]=ki*dp[1]+Ei*0+other*(dp[fa[i]]+1+sigma(dp[child[i]]+1)),设j=nx[i],则sigma(dp[child[i]]+1)
=sigma(Aj)*dp[1]+sigma(Bj)*dp[fa[j]]+sigma(Cj),带入原式可以得到Ai=(ki+other*sigma(Aj))/(1-other*sigma(Bj)),
Bi=other/(1-other*sigma(Bj)),Ci=(re[i]+other)/(1-other*sigma(Bj))
    因此一个dfs即可.

代码：
bool dfs(int from,int pre){
    int m = g[from].size();
    double other = re[from]/m;
    double a = k[from],b = 1,c = re[from];
    for(int i=0;i<m;i++){
        int to = g[from][i];
        if(to==pre) continue;
        if(!dfs(to,from)) return false;
        a+=other*A[to]; b-=other*B[to]; c+=other*C[to];
    }
    if(b<eps) return false;
    A[from]=a/b; B[from]=other/b; C[from]=c/b;
    return true;
}

9.Activation
题意：
    Tomato在排队激活游戏,有四种情况:1.注册失败,但是不影响队列顺序,概率为p1 2.连接失败,队首的人排到队尾,概率为p2
3.注册成功,队首离开队列,概率为p3  4.服务器崩溃,激活停止,概率为p4,现在给出总排队人数n,Tomato排在第m个,一个数k，然后是四种情况
的概率p1-p4;如果Tomato前面在k-1个人之内,并且服务器崩溃了,那么这种情况Tomato认为服务器是很low的.问你,发生这种很low的情况的概率。

思路:
    设dp[i][j]为目前有i个人排队,Tomato排在第j个位置发生这种情况的概率.
    当j=1时，dp[i][j] = p1*dp[i][j]+p2*dp[i][i]+p4；
    当1<j<=k时，dp[i][j]= p1*dp[i][j]+p2*dp[i][j-1]+p3*dp[i-1][j-1]+p4;
    当k<j<=i时，dp[i][j] = p1*dp[i][j]+p2*dp[i][j-1]+p3*dp[i-1][j-1];
    化简得：
    当j=1时，dp[i][j] = p21*dp[i][i]+p41；
    当1<j<=k时，dp[i][j]= p21*dp[i][j-1]+p31*dp[i-1][j-1]+p41;
    当k<j<=i时，dp[i][j] = p21*dp[i][j-1]+p31*dp[i-1][j-1];
    其中：p21=p2/(1-p1)、p31=p3/(1-p1)、p41=p4/(1-p1);
    循环i：1-n；
    由上面的式子可以看出，求dp[i][j]的时候dp[i-1][j-1]是已经计算出来了的。我们不妨把后面的部分用c数组保存起来，得到：
    当j=1时，dp[i][j] = p21*dp[i][i]+c[1]；
    当1<j<=k时，dp[i][j]= p21*dp[i][j-1]+c[j]，其中，c[j]=p31*dp[i-1][j-1]+p41;
    当k<j<=i时，dp[i][j] = p21*dp[i][j-1]+c[j]，其中c[j]=p31*dp[i-1][j-1];
    显然，dp[i][1]与dp[i][i]有关，而dp[i][j]又与dp[i][j-1]有关，这样就形成了一个环。所以，我们先利用上面3个式子迭代求出dp[i][i]：
    dp[i][i]=dp[i][i]*p21^i+c[1]*p21^i-1+c[2]*p21^i-2+......+c[i]；变个形即可求出dp[i][i]
    得出dp[i][i]，那么dp[i][1]也可以得出，之后就递推就行了。

//////////////////////////////////////////////////////
 
 3、Kids and Prizes(sgu495)
 题意：
     本题就是有n个奖品，m个人排队来选礼物，对于每个人，他打开的盒子，可能有礼物，也有可能已经被之前的人取走了，
 然后把盒子放回原处。为最后m个人取走礼物的期望。
 
 思路：
 1、设每种礼物不会被拿到的概率为((n-1)/n)^m,因此不会被拿到的期望为n*((n-1)/n)^m，所以会拿到的期望为n(1-((n-1)/n)^m)
 2、设dp[i]为总共i个人取得礼物时所拿到奖品的期望，则dp[1]=1,显然满足状态转移方程：
 dp[i] = dp[i-1] + (n-dp[i-1])/n*1+dp[i-1]/n*0 => dp[i] = dp[i-1] + (n-dp[i-1])/n 
 
 反思：
     概率题推期望不是只有一种模式逆推，要结合具体情况，通过赋予对状态转移方程的实际意义来推导。对于概率的题如果实在推不出来
 可以尝试使用日常经验的手段去推。
	  

	  
5、Where is the canteen(hdu2262)
题意：
    在一个迷宫中，寻找餐厅，餐厅有多个，每次上下左右走向一个空地，概率为等可能，求到达餐厅的步数期望
    
思路：
    显然此题满足概率dp,状态转移方程满足 dp[i][j]=p1*dp[i+1][j]+p2*dp[i-1][j]+p3*dp[i][j-1]+p4*
dp[i][j+1]+1,其中点为餐厅的dp[i][j]=0，求最后dp[startx][starty]为多少？因此只需要先bfs，然后使用
高斯消元即可获得答案。 关键在于转移方程的理解。dp[i][j]表示到达餐厅还剩下多少步，因此它的步数是由其余
四个防线的dp[i][j]*p+移动步数1即可。

反思：代码不够优美，要多看看优美的代码